<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ÁáüÈ§äÊé•Êé•Ê®Ç</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100dvh;
      width: 100vw;
      overflow: hidden;
    }
    .screen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100dvh;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      display: none;
    }
    .active {
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }
    .hotspot {
      position: absolute;
      width: 500px;
      height: 100px;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      cursor: pointer;
    }
    #permissionTip {
      position: absolute;
      bottom: 150px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255,255,255,0.9);
      padding: 10px 20px;
      border-radius: 10px;
      font-size: 16px;
      color: #000;
      display: none;
    }
    canvas {
      display: block;
      pointer-events: none;
      z-index: -1;
      position: relative;
    }
  </style>
</head>

<body>
  <!-- üöÄ ËºâÂÖ•Áï´Èù¢ (‰∏ÄÈñãÂßãÈ°ØÁ§∫ active) -->
  <div id="loading" class="screen active" 
     style="background: black; color: white; display: flex; justify-content: center; align-items: center; flex-direction: column;">
    <div id="loadingText" style="font-size: 28px;">ËºâÂÖ•‰∏≠...</div>
  </div>
  
  <!-- È¶ñÈ†Å (Â∞ÅÈù¢) ‚û°Ô∏è ‰∏ÄÈñãÂßã‰∏çË¶Å active -->
  <div id="home" class="screen" style="background-image: url('images/cover.jpg');">
    <div class="hotspot" onclick="showScreen('intro')"></div>
  </div>
  
  <!-- ÊèêÁ§∫È†Å (intro) -->
  <div id="intro" class="screen" style="background-image: url('images/intro.jpg');">
    <div id="permissionTip">Please allow device orientation access to enable tilt control.</div>
    <div class="hotspot" onclick="showScreen('K1Transition')"></div>
  </div>
  
  <!-- K1 ÈÅéÂ†¥ -->
  <div id="K1Transition" class="screen" style="background-image: url('images/K1.jpg');">
    <div class="hotspot" onclick="startGame()"></div>
  </div>

  <div id="gameCanvasContainer" class="screen">
    <canvas id="gameCanvas"></canvas>
  </div>

  <div id="betweenLevel" class="screen">
    <div class="hotspot" onclick="nextLevelStart()"></div>
  </div>

  <div id="result" class="screen">
    <div id="scoreResult"></div>
    <div class="hotspot" onclick="location.reload()"></div>
  </div>

  <script>
    const bgm = new Audio('sounds/bgm.mp3');
    bgm.loop = true;
    bgm.volume = 0.1;

    // ========== Èü≥Ë®äËß£ÈéñÔºö‰∏ÄÊ¨°ÊÄßÁÑ°ËÅ≤ BufferÔºà‰∏çËß∏Áôº‰ªª‰ΩïÁõÆÈåÑÈü≥Ôºâ ==========
    let audioUnlocked = false;
    async function unlockAudioOnce() {
      if (audioUnlocked) return;
      audioUnlocked = true;
      try {
        const AC = window.AudioContext || window.webkitAudioContext;
        if (!AC) return;
        const ctx = new AC();
        await ctx.resume();               // ÈúÄÂú®‰ΩøÁî®ËÄÖ‰∫íÂãïÂæåÂëºÂè´
        const buffer = ctx.createBuffer(1, 1, 22050); // 1 ÂÄãÊ®£Êú¨ÔºåÂÆåÂÖ®ÁÑ°ËÅ≤
        const src = ctx.createBufferSource();
        src.buffer = buffer;
        src.connect(ctx.destination);
        src.start(0);                     // Êí≠ÊîæÁÑ°ËÅ≤ 1-sample
        setTimeout(() => { try { ctx.close(); } catch(e){} }, 120);
      } catch (e) {
        console.log('unlockAudioOnce Â§±Êïó‰ΩÜÂèØÂøΩÁï•Ôºö', e);
      }
    }

    // Á©©ÂÆöÁöÑÈü≥ÊïàÊ±†ÔºöÊåëÁ©∫ÈñíÈü≥Ëªå + ÂÆâÂÖ®ÈáçÁΩÆ + Â§±ÊïóÈáçË©¶
    function createSoundPool(src, poolSize = 6) {
      const pool = Array.from({ length: poolSize }, () => {
        const audio = new Audio(src);
        audio.preload = "auto"; // ÂÖàË°åÈ†êËºâ
        return audio;
      });

      function getIdleAudio() {
        for (const a of pool) {
          if (a.paused || a.ended) return a;
        }
        return pool[0]; // ÂÖ®ÈÉ®Âú®Êí≠ÊôÇË¶ÜËìãÁ¨¨‰∏ÄÂÄã
      }

     async function safePlay(a, volume) {
  try {
    // Â¶ÇÊûúÊ≠£Âú®Êí≠ÊîæÔºå‰∏çË¶ÅÂº∑Âà∂‰∏≠Êñ∑ ‚Üí Áõ¥Êé•Âª∫Á´ãÊñ∞ÁöÑ Audio
    if (!a.paused && !a.ended) {
      const clone = a.cloneNode();  // Ë§áË£Ω‰∏ÄÂÄãÊñ∞ÁöÑÈü≥Ëªå
      clone.volume = volume;
      clone.muted = false;
      await clone.play();
      return;
    }

    // Â¶ÇÊûúÁ©∫ÈñíÊâçÈáçÁΩÆ
    a.currentTime = 0;
    a.volume = volume;
    a.muted = false;
    await a.play();
  } catch (err) {
    console.warn("Èü≥ÊïàÊí≠ÊîæÂ§±Êïó:", err);
  }
}

      return {
        play(volume = 1) {
          const a = getIdleAudio();
          safePlay(a, volume);
        },
        // ÂÉÖ‰æõÈ†êËºâ‰ΩøÁî®Ôºå‰∏çÊúÉÊí≠Êîæ
        preload() {
          pool.forEach(a => { try { a.load(); } catch(e){} });
        },
        _all() { return pool; }
      };
    }

    const clickSoundPool = createSoundPool('sounds/click.mp3');
    const goodSoundPool   = createSoundPool('sounds/good.mp3');   // ‚úÖ Ê≠£Á¢∫Èü≥ÊïàÔºàÊ™îÂêç‰æù‰Ω†Êèê‰æõÔºâ
    const badSoundPool   = createSoundPool('sounds/bad.mp3');   // ‚ùå ‰∏çÂÅ•Â∫∑
    const wrongSoundPool = createSoundPool('sounds/wrong.mp3'); // ‚ö†Ô∏è È†ÜÂ∫è‰∏çÂ∞ç

    // üîá È†êÁÜ±ÊóóÊ®ôÔºà‰∏çÂÜçÊí≠ÊîæÔºåÂè™ÂÅöÈ†êËºâ loadÔºâ
    let sfxWarmedUp = false;
    function warmUpSoundPools() {
      if (sfxWarmedUp) return;
      sfxWarmedUp = true;
      // ÂÉÖÈ†êËºâÔºå‰∏ç play ‚Üí ÂÆåÂÖ®‰∏çÊúÉÂá∫ËÅ≤
      [clickSoundPool, goodSoundPool, badSoundPool, wrongSoundPool].forEach(p => p.preload());
    }

    function handleClickFeedback() {
      // Ëã•‰∏çÂ∏åÊúõÊåâÈàïÊúâËÅ≤Èü≥ÔºåË®ªËß£‰∏ã‰∏ÄË°å
      clickSoundPool.play();
      if (navigator.vibrate) navigator.vibrate(80);
    }

    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // ÂàùÂßãÂåñÊôÇÂ∞±Áµ¶Ê≠£Á¢∫Â§ßÂ∞è
    const basket = { 
      x: canvas.width / 2 - 60, 
      y: canvas.height - 100, 
      width: 120,   // Âíå drawImage ‰∏ÄËá¥
      height: 80    // ÂíåÁ¢óÂúñ‰∏ÄËá¥
    };
    let currentFood = null;
    let foodQueue = [], score = 0, level = 1;
    let stats = { 1: { good: 0, bad: 0 }, 2: { good: 0, bad: 0 }, 3: { good: 0, bad: 0 } };
    let bgTimeout = null;
    const permissionTip = document.getElementById("permissionTip");

    const bgImages = { 0: new Image(), 1: new Image(), 2: new Image(), 3: new Image() };
    bgImages[0].src = "images/bg0.jpg";
    bgImages[1].src = "images/bg1.jpg";
    bgImages[2].src = "images/bg2.jpg";
    bgImages[3].src = "images/bg3.jpg";
    let bgImg = bgImages[0];

    const transitionScreens = { 1: "images/K2.jpg", 2: "images/K3.jpg" };

    const bowlImg = new Image();
    bowlImg.src = 'images/bowl.png';

    const allFoods = [
      { file: "GM1.png", type: "meat",       health: "good" },
      { file: "GM3.png", type: "meat",       health: "good" },
      { file: "GM4.png", type: "meat",       health: "good" },
      { file: "GM5.png", type: "meat",       health: "good" },
      { file: "BM2.png", type: "meat",       health: "bad"  },
      { file: "BM3.png", type: "meat",       health: "bad"  },
      { file: "GV1.png", type: "vegetable",  health: "good" },
      { file: "GV2.png", type: "vegetable",  health: "good" },
      { file: "GV3.png", type: "vegetable",  health: "good" },
      { file: "GV4.png", type: "vegetable",  health: "good" },
      { file: "GV5.png", type: "vegetable",  health: "good" },
      { file: "GStrach1.png", type: "rice",  health: "good" },
      { file: "GStrach3.png", type: "rice",  health: "good" },
      { file: "BStrach1.png", type: "rice",  health: "bad"  },
      { file: "BStrach2.png", type: "rice",  health: "bad"  },
      { file: "BStrach3.png", type: "rice",  health: "bad"  },
    ];

    function showScreen(id) {
      document.querySelectorAll(".screen").forEach(s => s.classList.remove("active"));
      document.getElementById(id).classList.add("active");
    }

function preloadAudio(audioList, callback) {
  const total = audioList.length;
  let loadedCount = 0;
  const loadingText = document.getElementById("loadingText");
  let finished = false;

  function checkDone() {
    if (finished) return;
    loadedCount++;
    loadingText.textContent = `ËºâÂÖ•‰∏≠... ${loadedCount}/${total}`;
    if (loadedCount >= total) {
      finished = true;
      callback();
    }
  }

  audioList.forEach(audio => {
    // ÂòóË©¶Âº∑Âà∂ÁÄèË¶ΩÂô®ÈñãÂßã‰∏ãËºâ
    try { audio.load(); } catch(e){}

    // ÊàëÂÄë‰∏çÁ≠â canplaythroughÔºåÁõ¥Êé•Áµ¶ÂÄãÊúÄÁü≠Âª∂ÈÅ≤
    setTimeout(checkDone, 50);
  });

  // ÂæåÂÇô timeoutÔºåÈÅøÂÖçËê¨‰∏ÄÂá∫ÁèæÁï∞Â∏∏
  setTimeout(() => {
    if (!finished) {
      console.warn("‚ö†Ô∏è Èü≥ÊïàÈ†êËºâË∂ÖÊôÇÔºåÁõ¥Êé•ÈÄ≤ÂÖ•ÈÅäÊà≤");
      finished = true;
      callback();
    }
  }, 3000);
}


function startGame() {
  showScreen("loading"); // È°ØÁ§∫ loading Áï´Èù¢
  const loadingText = document.getElementById("loadingText");
  loadingText.textContent = "ËºâÂÖ•ËÉåÊôØÈü≥Ê®Ç‰∏≠...";

  // Âè™Âº∑Âà∂Á≠â BGMÔºåÂÖ∂‰ªñÈü≥Êïà‰∏üÁµ¶ preload
  bgm.addEventListener("canplaythrough", () => {
    console.log("üéµ BGM Â∑≤ËºâÂÖ•ÂÆåÊàê");
    loadingText.textContent = "ËºâÂÖ•ÂÆåÊàêÔºåÈñãÂßãÈÅäÊà≤ÔºÅ";

    // È†êËºâÂÖ∂‰ªñÈü≥ÊïàÔºà‰∏çÂΩ±ÈüøÊµÅÁ®ãÔºâ
    const allSfx = [
      ...clickSoundPool._all(),
      ...goodSoundPool._all(),
      ...badSoundPool._all(),
      ...wrongSoundPool._all()
    ];
    allSfx.forEach(a => { try { a.load(); } catch(e){} });
    warmUpSoundPools();

    // ‚úÖ Ê≠£ÂºèÈñãÂßãÈÅäÊà≤
    unlockAudioOnce();
    showScreen("gameCanvasContainer");
    requestDeviceOrientation();
    level = 1;
    score = 0;
    prepareLevel();
    loop();
    bgm.play().catch(() => console.log("Èü≥Ê®ÇÊí≠ÊîæÂ§±Êïó"));
  }, { once: true });

  // ÂòóË©¶Ëß∏Áôº BGM ËºâÂÖ•
  try { bgm.load(); } catch(e) {}
}

    function prepareLevel() {
      foodQueue = [];
      const correctFoods = allFoods.filter(f =>
        (level === 1 && f.type === 'meat'      && f.health === 'good') ||
        (level === 2 && f.type === 'vegetable' && f.health === 'good') ||
        (level === 3 && f.type === 'rice'      && f.health === 'good')
      );
      const incorrectFoods = allFoods.filter(f => !correctFoods.includes(f));
      for (let i = 0; i < 10; i++) {
        foodQueue.push(correctFoods[Math.floor(Math.random() * correctFoods.length)]);
        foodQueue.push(incorrectFoods[Math.floor(Math.random() * incorrectFoods.length)]);
      }
      spawnFood();
      startLevelTimer();
    }

    function spawnFood() {
      if (currentFood || foodQueue.length === 0) return;
      const f = foodQueue.shift();
      const img = new Image();
      img.onload = () => {
        currentFood = {
          ...f,
          image: img,
          x: Math.random() * (canvas.width - 80),
          y: 0,
          size: 90,
          speed: 3
        };
      };
      img.src = `images/${f.file}`;
    }

    // ===== ÂëΩ‰∏≠Âà§ÂÆöÈõ£Â∫¶Ë®≠ÂÆö =====
    // ÂèØÈÅ∏ 'easy' | 'normal' | 'hard' | 'custom'
    let hitboxDifficulty = 'hard';

    const HITBOX_PRESETS = {
      easy:   { shrinkX: 5,  verticalTolerance: 40 },
      normal: { shrinkX: 15, verticalTolerance: 25 },
      hard:   { shrinkX: 25, verticalTolerance: 15 },
    };

    const HITBOX_CUSTOM = { shrinkX: 20, verticalTolerance: 20 };

    function getHitboxParams() {
      if (hitboxDifficulty === 'custom') return HITBOX_CUSTOM;
      return HITBOX_PRESETS[hitboxDifficulty] || HITBOX_PRESETS.normal;
    }

    // Á∏ÆÂ∞èÂà§ÂÆöÂçÄÂüüÔºàÂ∑¶Âè≥Êî∂Á™Ñ + ÂûÇÁõ¥ÂÆπÂ∑ÆÔºâ
    function isColliding(food, basket) {
      const { shrinkX, verticalTolerance } = getHitboxParams();

      const foodBottom = food.y + food.size;
      const foodCenterX = food.x + food.size / 2;

      const plateTop = basket.y;
      const plateLeft = basket.x + shrinkX;
      const plateRight = basket.x + basket.width - shrinkX;

      return (
        foodBottom >= plateTop &&
        foodBottom <= plateTop + verticalTolerance &&
        foodCenterX > plateLeft &&
        foodCenterX < plateRight
      );
    }

    function update() {
      if (!currentFood) return;
      currentFood.y += currentFood.speed;
      const caught = isColliding(currentFood, basket);
      const missed = currentFood.y > canvas.height;

      if (caught || missed) {
        if (caught) handleCatch(currentFood);
        currentFood = null;
        if (foodQueue.length > 0) spawnFood();
        else showTransition();
      }
    }

    // ‚úÖ ÊØèÊ¨°Êé•Âà∞È£üÁâ©ÈÉΩÂøÖÂÆöËß∏ÁôºÈü≥ÊïàÔºàÁÑ°ÂÖ®ÂüüÂÜ∑ÂçªÔºâ
    function handleCatch(food) {
      if (navigator.vibrate) navigator.vibrate(30);

      if (food.health === 'bad') {
        score -= 2;
        stats[level].bad++;
        bgImg = bgImages[3];
        badSoundPool.play(1);          // ‚ùå ‰∏çÂÅ•Â∫∑ ‚Üí ÈåØË™§Èü≥
      } else if (
        (level === 1 && food.type === 'meat') ||
        (level === 2 && food.type === 'vegetable') ||
        (level === 3 && food.type === 'rice')
      ) {
        score += 2;
        stats[level].good++;
        bgImg = bgImages[1];
        goodSoundPool.play(1);          // ‚úÖ Êú¨ÈóúÂÅ•Â∫∑ÁõÆÊ®ô ‚Üí Ê≠£Á¢∫Èü≥Ôºàgood.mp3Ôºâ
      } else {
        score -= 1;
        stats[level].bad++;
        bgImg = bgImages[2];
        wrongSoundPool.play(1);        // ‚ö†Ô∏è ÂÅ•Â∫∑‰ΩÜÈùûÁõÆÊ®ô ‚Üí È†ÜÂ∫è‰∏çÂ∞ç
      }

      if (bgTimeout) clearTimeout(bgTimeout);
      bgTimeout = setTimeout(() => { bgImg = bgImages[0]; }, 3000);
    }

    let levelTime = 65;
    let timeLeft = levelTime;
    let timerInterval = null;

     function getLevelTarget(level) {
      if (level === 1) return "Êú¨ÈóúÁõÆÊ®ôÔºöÂè™ÂêÉÂÅ•Â∫∑ËõãÁôΩË≥™";
      if (level === 2) return "Êú¨ÈóúÁõÆÊ®ôÔºöÂè™ÂêÉËî¨Ëèú";
      if (level === 3) return "Êú¨ÈóúÁõÆÊ®ôÔºöÂè™ÂêÉÂÅ•Â∫∑Êæ±Á≤â";
      return "";
    }

    function draw() {
      if (bgImg.complete) ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
      if (bowlImg.complete) ctx.drawImage(bowlImg, basket.x, basket.y, basket.width, basket.height);
      if (currentFood?.image?.complete) ctx.drawImage(currentFood.image, currentFood.x, currentFood.y, currentFood.size, currentFood.size);
      ctx.font = "bold 24px sans-serif";
      ctx.fillStyle = "black";
      ctx.fillText(`ÈóúÂç° ${level} ÂàÜÊï∏:${score}`, 10, 40);
      ctx.textAlign = "right";
      ctx.fillText(`Ââ©È§òÊôÇÈñì: ${timeLeft}s`, canvas.width - 10, 40);
      ctx.textAlign = "left";
      ctx.fillText(getLevelTarget(level), 10, 80);
    }

    function startLevelTimer() {
      timeLeft = levelTime;
      clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        timeLeft--;
        if (timeLeft <= 0) {
          clearInterval(timerInterval);
          showTransition();
        }
      }, 1000);
    }

    function loop() {
      update();
      draw();
      if (level <= 3) requestAnimationFrame(loop);
    }

    function showTransition() {
      clearInterval(timerInterval);
      if (level < 3) {
        document.getElementById("betweenLevel").style.backgroundImage = `url('${transitionScreens[level]}')`;
        showScreen("betweenLevel");
      } else showResult();
    }

    function nextLevelStart() {
      level++;
      showScreen("gameCanvasContainer");
      prepareLevel();
    }

    function showResult() {
      clearInterval(timerInterval);
      showScreen("result");
      const bg = score >= 20 ? "result1.jpg" : score >= 10 ? "result2.jpg" : "result3.jpg";
      document.getElementById("result").style.backgroundImage = `url('images/${bg}')`;
      document.getElementById("scoreResult").innerHTML = "";
      setTimeout(() => {
        document.getElementById("scoreResult").innerHTML = `
          <div style="font-size: 60px; color: red; font-weight: bold; text-shadow: 2px 2px 4px white; margin-bottom: 100px;">
            ${score} ÂàÜÔºÅ
          </div>`;
      }, 800);
    }

    function requestDeviceOrientation() {
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        permissionTip.style.display = 'block';
        DeviceOrientationEvent.requestPermission().then(res => {
          if (res === 'granted') {
            window.addEventListener("deviceorientation", handleOrientation);
            permissionTip.style.display = 'none';
          }
        }).catch(() => permissionTip.textContent = "Ë£ùÁΩÆÊñπÂêëÊ¨äÈôêÊú™ÈñãÂïü");
      } else window.addEventListener("deviceorientation", handleOrientation);
    }

    function handleOrientation(event) {
      const tilt = event.gamma;
      if (tilt != null) {
        basket.x += tilt * 0.5;
        basket.x = Math.max(0, Math.min(canvas.width - basket.width, basket.x));
      }
    }

    window.onload = () => {
      document.querySelectorAll('.hotspot').forEach(button => {
        const original = button.onclick;
        button.onclick = (e) => {
          handleClickFeedback();   // ÂèØËÉΩÂè™Âú®È¶ñÈ†Å/ÈÅéÂ†¥Ë¢´ÈªûÂà∞
          if (typeof original === 'function') original.call(button, e);
        };
      });
    }

// ===== ÊîæÂú®ÊúÄ‰∏ãÈù¢ =====
  window.addEventListener("load", () => {
    const loadingText = document.getElementById("loadingText");

    let loaded = 0;
    const toLoad = [bgm, "images/cover.jpg", "images/intro.jpg", "images/K1.jpg"];

    function checkDone() {
      loaded++;
      loadingText.textContent = `ËºâÂÖ•‰∏≠... ${loaded}/${toLoad.length}`;
      if (loaded >= toLoad.length) {
        setTimeout(() => {
          showScreen("home"); // ‚úÖ ËºâÂÆåÂæåÂàáÂà∞È¶ñÈ†Å
        }, 500);
      }
    }

    bgm.addEventListener("canplaythrough", checkDone, { once: true });
    try { bgm.load(); } catch(e) {}

    toLoad.slice(1).forEach(src => {
      const img = new Image();
      img.onload = checkDone;
      img.onerror = checkDone;
      img.src = src;
    });

    showScreen("loading");
  });
  </script>
</body>
</html>

